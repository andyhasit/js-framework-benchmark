export const h=(e,...t)=>{let r=document.createElement(e);if(isAttrs(t[0])){let e=t.shift();for(let t in e){let n=e[t];n&&n.isBoundAttribute&&(n.init(t,r),n=n()),setAttribute(t,n,r)}}for(let e of t)if(Array.isArray(e))for(let t of e)r.append(renderNode(t));else r.append(renderNode(e));return r};export const fnstate=(e,t)=>{let r={currentValue:e,observers:[],bindContexts:[],selectObservers:{},mapKey:t,state(e){if(0===arguments.length)return r.currentValue;r.currentValue=e;for(let t of r.observers)t(e);return e}};return r.state.bindValues=(e,t,n)=>doBindValues(r,e,t,n),r.state.bindAs=(e,t)=>doBindAs(r,e,t),r.state.bindAttr=e=>doBindAttr(r.state,e),r.state.bindSelect=(e,t)=>doBindSelect(r,e,t),r.state.bindSelectAttr=e=>doBindSelectAttr(r,e),r.state.select=e=>doSelect(r,e),r.state.selected=()=>r.selected,r.state.isFnState=!0,r.state.patch=e=>r.state(Object.assign(r.currentValue,e)),r.state.subscribe=e=>r.observers.push(e),r.state.reset=t=>doReset(r,t,e),r.state};const subscribeSelect=(e,t)=>{let r=e.state.parentCtx,n=keyMapper(r.mapKey,e.currentValue);r&&(r.selectObservers[n]||(r.selectObservers[n]=[]),r.selectObservers[n].push(t))};export const isNode=e=>e instanceof Node;let doBindSelectAttr=function(e,t){let r=createBoundAttr(t);return r.init=(r,n)=>subscribeSelect(e,(()=>setAttribute(r,t(),n))),r};function createBoundAttr(e){if("function"!=typeof e)throw new Error("You must pass a function to bindAttr");let t=()=>e();return t.isBoundAttribute=!0,t}function doBindAttr(e,t){let r=createBoundAttr(t);return r.init=(r,n)=>e.subscribe((()=>setAttribute(r,t(),n))),r}function doReset(e,t,r){e.observers=[],e.selectObservers={},t&&(e.currentValue=r)}function doSelect(e,t){let r=e.selected;e.selected=t,e.selectObservers[r]&&e.selectObservers[r].forEach((e=>e())),e.selectObservers[e.selected]&&e.selectObservers[e.selected].forEach((e=>e()))}function doBindValues(e,t,r,n){if(!(t=renderNode(t)))throw new Error("You must provide a parent element to bind the children to. aka Need Bukkit.");if("function"!=typeof r&&!n)throw new Error("You must pass an update function when passing a non function element");return e.mapKey||(console.warn("Using value index as key, may not work correctly when moving items..."),e.mapKey=(e,t)=>t),Array.isArray(e.currentValue)?(e.currentValue=e.currentValue.map((e=>e.isFnState?e:fnstate(e))),e.bindContexts.push({element:r,update:n,parent:t}),e.state.subscribe((()=>{Array.isArray(e.currentValue)?reconcile(e):(console.warn("A state used with bindValues was updated to a non array value. This will be converted to an array of 1 and the state will be updated."),setTimeout((()=>e.state([e.currentValue])),1))})),reconcile(e),t):e.state.bindAs(r,n)}let doBind=function(e,t,r,n,s){if("function"!=typeof t&&!r)throw new Error("You must pass an update function when passing a non function element");if(r){let r=renderNode(evaluateElement(t,e.currentValue));return n(r),r}{let r=setKey(e,renderNode(t(e.currentValue)));return s(r),r}};const doBindSelect=(e,t,r)=>doBind(e,t,r,(t=>subscribeSelect(e,(()=>r(t)))),(r=>{let n=keyMapper(e.state.parentCtx.mapKey,e.currentValue);subscribeSelect(e,(()=>{let s=renderNode(t(e.currentValue));s.key=n,r.replaceWith(s),r=s}))})),doBindAs=(e,t,r)=>doBind(e,t,r,(t=>{e.state.subscribe((()=>r(t)))}),(r=>{e.state.subscribe((()=>{let n=setKey(e,renderNode(t(e.currentValue)));n&&(n.key&&n.key===r.key||(r.replaceWith(n),r=n))}))}));function reconcile(e){for(let t of e.bindContexts)t.boundElementByKey||(t.boundElementByKey={}),arrangeElements(e,t)}function setKey(e,t){return!t.key&&e.mapKey&&(t.key=keyMapper(e.mapKey,e.currentValue)),t}function keyMapper(e,t){return"object"!=typeof t?t:e?e(t):0}function arrangeElements(e,t){if(0===e.currentValue.length)return t.parent.textContent="",void(t.boundElementByKey={});let r=Object.keys(t.boundElementByKey).reduce(((e,t)=>(e[t]=!0)&&e),{}),n=null,s=t.parent,o={};for(let a=e.currentValue.length-1;a>=0;a--){let l=e.currentValue[a];l&&l.isFnState||(l=e.currentValue[a]=fnstate(l));let i=keyMapper(e.mapKey,l());if(o[i])throw new Error("Duplicate keys in a bound array are not allowed.");o[i]=!0;let u=t.boundElementByKey[i],c=!1;l.parentCtx||(l.parentCtx=e),u||(c=!0,u=t.boundElementByKey[i]=renderNode(evaluateElement(t.element,l)),u.key=i),n?n.previousSibling?n.previousSibling.key!==u.key&&(c?n.insertAdjacentElement("beforeBegin",u):n.previousSibling.replaceWith(u)):n.insertAdjacentElement("beforeBegin",u):s.lastChild&&s.lastChild.key===u.key||s.append(u),n=u,delete r[i]}for(let n of Object.keys(r))e.selected===n&&(e.selected=null),t.boundElementByKey[n].remove(),delete t.boundElementByKey[n]}const evaluateElement=(e,t)=>"function"==typeof e?e(t):e;export const renderNode=e=>{if("object"==typeof e&&void 0===e.then)return e;if(e&&"function"==typeof e.then){const e=marker();return e.then((t=>e.replaceWith(renderNode(t)))).catch((e=>console.error("Caught failed node promise.",e))),e}return document.createTextNode(e+"")};let setAttribute=function(e,t,r){if("string"==typeof t||"value"===e)r.setAttribute(e,t);else if("style"===e&&"object"==typeof t)for(let e in t){let n=t[e].toString().match(/(.*)\W+!important\W*$/);n?r.style.setProperty(e,n[1],"important"):r.style.setProperty(e,t[e])}else e.startsWith("on")&&"function"==typeof t?r.addEventListener(e.substring(2),t):r[e]=t};export const isAttrs=e=>e&&"object"==typeof e&&!Array.isArray(e)&&!(e instanceof Node);export const getAttrs=e=>isAttrs(e[0])?e[0]:{};const marker=e=>h("div",Object.assign(e||{},{style:"display:none"}));